),
plotOutput("venn_plot", height = "600px"),
div(id = "venn_explanation", style = "margin-top: 15px;")
)
})
# Bouton de diagnostic pour vérifier le stockage des gènes
observeEvent(input$check_gene_storage, {
stored_tables <- gene_table_storage()
if (length(stored_tables) == 0) {
html_content <- "No tables stored in gene_table_storage"
} else {
html_content <- "<h4>Stored tables:</h4><ul>"
for (name in names(stored_tables)) {
table_info <- stored_tables[[name]]
html_content <- paste0(
html_content,
"<li><strong>", name, "</strong> (", table_info$description, ") : ",
nrow(table_info$data), " genes | Type: ", table_info$type, " | Timestamp: ",
format(table_info$timestamp, "%Y-%m-%d %H:%M:%S"), "</li>"
)
}
html_content <- paste0(html_content, "</ul>")
}
showModal(modalDialog(
title = "Gene Storage Diagnostic",
HTML(html_content),
easyClose = TRUE,
footer = modalButton("Close")
))
})
# Observer pour générer le diagramme Venn
observeEvent(input$generate_venn, {
tryCatch({
req(gene_table_storage(), input$venn_gene_tables)
selected_table_names <- input$venn_gene_tables
# Vérifier qu'on a sélectionné 2 à 5 tableaux
if (length(selected_table_names) < 2 || length(selected_table_names) > 5) {
showNotification("Please select between 2 and 5 gene tables for the Venn diagram.", type = "warning")
return()
}
# Récupérer les tableaux stockés
all_tables <- gene_table_storage()
# Créer les listes de gènes
gene_lists <- list()
gene_counts <- list()
list_names <- character()
for (name in selected_table_names) {
if (name %in% names(all_tables)) {
table_info <- all_tables[[name]]
# Extraire les noms de gènes
if ("gene" %in% colnames(table_info$data)) {
genes <- gsub("<.*?>", "", table_info$data$gene)
} else {
genes <- rownames(table_info$data)
}
# S'assurer que genes n'est pas NULL
if (is.null(genes)) {
genes <- character(0)
}
# Filtrer par p-value et FC si disponibles
if ("p_val" %in% colnames(table_info$data) && "avg_log2FC" %in% colnames(table_info$data)) {
# Conversion en numérique avec gestion des erreurs
p_vals <- tryCatch({
as.numeric(gsub("<", "", as.character(table_info$data$p_val)))
}, error = function(e) {
rep(1, length(genes))  # Valeur par défaut si conversion impossible
})
logfc <- tryCatch({
as.numeric(gsub("<", "", as.character(table_info$data$avg_log2FC)))
}, error = function(e) {
rep(0, length(genes))  # Valeur par défaut si conversion impossible
})
# Vérifier longueurs égales
if (length(p_vals) == length(genes) && length(logfc) == length(genes)) {
# Appliquer les filtres
significant_indices <- which(p_vals < input$pvalue_threshold_venn & abs(logfc) > input$logfc_threshold_venn)
if (length(significant_indices) > 0) {
significant_genes <- genes[significant_indices]
} else {
significant_genes <- character(0)
}
} else {
significant_genes <- genes
}
} else {
significant_genes <- genes
}
# Ajouter à la liste (s'assurer qu'il n'est pas NULL)
if (length(significant_genes) > 0) {
gene_lists[[table_info$description]] <- significant_genes
gene_counts[[table_info$description]] <- length(significant_genes)
list_names <- c(list_names, table_info$description)
} else {
showNotification(paste0("No significant genes found in '", table_info$description, "' with current thresholds"), type = "warning")
}
}
}
# Vérifier qu'il reste au moins 2 listes non vides
if (length(gene_lists) < 2) {
showNotification("Not enough gene lists with significant genes. Please adjust thresholds or select different tables.", type = "error")
return()
}
# Stocker les listes pour utilisation ultérieure
current_gene_lists(gene_lists)
# Créer une représentation simplifiée du diagramme de Venn
output$venn_plot <- renderPlot({
# Nombre d'ensembles
n_sets <- length(gene_lists)
# Utiliser une approche différente selon le nombre d'ensembles
if (n_sets == 2) {
# Deux ensembles - utiliser la version la plus simple
set1 <- gene_lists[[1]]
set2 <- gene_lists[[2]]
# Calculer les intersections avec vérification de non-NULL
if (length(set1) > 0 && length(set2) > 0) {
intersection <- intersect(set1, set2)
} else {
intersection <- character(0)
}
if (length(set1) > 0) {
only_set1 <- setdiff(set1, set2)
} else {
only_set1 <- character(0)
}
if (length(set2) > 0) {
only_set2 <- setdiff(set2, set1)
} else {
only_set2 <- character(0)
}
# Créer le diagramme
plot(c(-1, 1), c(-1, 1), type = "n", xlab = "", ylab = "",
main = "Venn Diagram", axes = FALSE)
# Dessiner les cercles
draw_circle <- function(x, y, r, col) {
theta <- seq(0, 2*pi, length.out = 200)
polygon(x + r*cos(theta), y + r*sin(theta), col = col, border = "black")
}
# Dessiner les cercles avec transparence
colors <- c("#66C2A5", "#FC8D62")
draw_circle(-0.4, 0, 0.7, adjustcolor(colors[1], alpha.f = 0.5))
draw_circle(0.4, 0, 0.7, adjustcolor(colors[2], alpha.f = 0.5))
# Ajouter les labels
text(-0.7, 0, names(gene_lists)[1], font = 2)
text(0.7, 0, names(gene_lists)[2], font = 2)
# Ajouter les comptes
text(-0.5, 0, paste0(length(only_set1)), cex = 1.5)
text(0.5, 0, paste0(length(only_set2)), cex = 1.5)
text(0, 0, paste0(length(intersection)), cex = 1.5)
} else if (n_sets == 3) {
# Trois ensembles - dessiner 3 cercles
set1 <- gene_lists[[1]]
set2 <- gene_lists[[2]]
set3 <- gene_lists[[3]]
# Calculer toutes les intersections possibles de façon sécurisée
set12 <- safe_intersect(set1, set2)
set13 <- safe_intersect(set1, set3)
set23 <- safe_intersect(set2, set3)
# Pour l'intersection des 3 ensembles, procéder étape par étape
if (length(set12) > 0 && length(set3) > 0) {
set123 <- safe_intersect(set12, set3)
} else {
set123 <- character(0)
}
# Calculer les ensembles exclusifs
only_set1 <- safe_setdiff(safe_setdiff(set1, set2), set3)
only_set2 <- safe_setdiff(safe_setdiff(set2, set1), set3)
only_set3 <- safe_setdiff(safe_setdiff(set3, set1), set2)
# Intersections exclusives
only_set12 <- safe_setdiff(set12, set3)
only_set13 <- safe_setdiff(set13, set2)
only_set23 <- safe_setdiff(set23, set1)
# Créer le diagramme
plot(c(-1.5, 1.5), c(-1.5, 1.5), type = "n", xlab = "", ylab = "",
main = "Venn Diagram of 3 Sets", axes = FALSE)
# Dessiner les cercles
draw_circle <- function(x, y, r, col) {
theta <- seq(0, 2*pi, length.out = 200)
polygon(x + r*cos(theta), y + r*sin(theta), col = col, border = "black")
}
# Positions des cercles
x1 <- -0.5
y1 <- 0.3
x2 <- 0.5
y2 <- 0.3
x3 <- 0
y3 <- -0.6
r <- 0.8
# Dessiner les cercles avec transparence
colors <- c("#66C2A5", "#FC8D62", "#8DA0CB")
draw_circle(x1, y1, r, adjustcolor(colors[1], alpha.f = 0.5))
draw_circle(x2, y2, r, adjustcolor(colors[2], alpha.f = 0.5))
draw_circle(x3, y3, r, adjustcolor(colors[3], alpha.f = 0.5))
# Ajouter les labels des ensembles
text(x1 - 0.4, y1 + 0.5, names(gene_lists)[1], font = 2)
text(x2 + 0.4, y2 + 0.5, names(gene_lists)[2], font = 2)
text(x3, y3 - 0.6, names(gene_lists)[3], font = 2)
# Ajouter les comptes
text(x1 - 0.4, y1, length(only_set1), cex = 1.2)
text(x2 + 0.4, y2, length(only_set2), cex = 1.2)
text(x3, y3 - 0.3, length(only_set3), cex = 1.2)
text((x1 + x2)/2, y1 + 0.1, length(only_set12), cex = 1.2)
text((x1 + x3)/2, (y1 + y3)/2, length(only_set13), cex = 1.2)
text((x2 + x3)/2, (y2 + y3)/2, length(only_set23), cex = 1.2)
text(0, 0, length(set123), cex = 1.5, font = 2)
} else {
# Pour 4 ou 5 ensembles, utiliser une visualisation plus simple pour éviter les erreurs
# Créer un tableau des intersections
counts <- sapply(gene_lists, length)
# Trouver la taille de chaque intersection de deux ensembles avec sécurité
intersection_matrix <- matrix(0, nrow = n_sets, ncol = n_sets)
rownames(intersection_matrix) <- names(gene_lists)
colnames(intersection_matrix) <- names(gene_lists)
for (i in 1:(n_sets-1)) {
for (j in (i+1):n_sets) {
name_i <- names(gene_lists)[i]
name_j <- names(gene_lists)[j]
if (length(gene_lists[[name_i]]) > 0 && length(gene_lists[[name_j]]) > 0) {
common <- length(intersect(gene_lists[[name_i]], gene_lists[[name_j]]))
} else {
common <- 0
}
intersection_matrix[i, j] <- common
intersection_matrix[j, i] <- common
}
}
# Calculer l'intersection de tous les ensembles de façon sécurisée
if (all(sapply(gene_lists, length) > 0)) {
all_common <- length(Reduce(intersect, gene_lists))
} else {
all_common <- 0
}
# Créer une visualisation simplifiée
layout(matrix(c(1,2), nrow=2), heights = c(1,2))
# Barplot des tailles
par(mar = c(8, 4, 2, 2))
barplot(counts, main = paste0(n_sets, "-way Venn Diagram"),
col = adjustcolor(rainbow(n_sets), alpha.f = 0.7),
names.arg = names(gene_lists), las = 2, cex.names = 0.7)
# Matrice des intersections
par(mar = c(5, 4, 4, 2))
plot(c(0, n_sets+1), c(0, n_sets+1), type = "n", xlab = "", ylab = "",
main = "Intersection Sizes", axes = FALSE)
# Dessiner la matrice
for (i in 1:n_sets) {
for (j in 1:n_sets) {
if (i != j) {
rect(i-0.4, j-0.4, i+0.4, j+0.4, col = ifelse(intersection_matrix[i,j] > 0, "lightblue", "white"), border = "gray")
if (intersection_matrix[i,j] > 0) {
text(i, j, intersection_matrix[i,j], cex = 0.8)
}
} else {
rect(i-0.4, j-0.4, i+0.4, j+0.4, col = adjustcolor(rainbow(n_sets)[i], alpha.f = 0.7), border = "gray")
text(i, j, counts[i], cex = 0.8, font = 2)
}
}
}
# Ajouter les noms
text(1:n_sets, 0, names(gene_lists), cex = 0.7, srt = 45, adj = c(1,1))
text(0, 1:n_sets, names(gene_lists), cex = 0.7, adj = c(1,0.5))
# Intersection de tous les ensembles
text(n_sets/2 + 0.5, n_sets/2 + 0.5,
paste0("All sets intersection: ", all_common, " genes"),
cex = 1.2, font = 2)
}
})
# Ajouter une explication sous le graphique
output$venn_explanation <- renderUI({
# Calculer les intersections de façon sécurisée
all_sets <- unique(unlist(gene_lists))
# Pour l'intersection de tous les ensembles, on vérifie d'abord que tous les ensembles ont des éléments
if (all(sapply(gene_lists, length) > 0)) {
common_all <- Reduce(intersect, gene_lists)
} else {
common_all <- character(0)
}
# Informations générales
html_content <- paste0(
"<h4>Summary:</h4>",
"<ul>",
"<li>Total unique genes across all sets: ", length(all_sets), "</li>",
"<li>Genes common to all sets: ", length(common_all), "</li>"
)
# Ajouter des informations sur chaque ensemble
for (i in 1:length(gene_lists)) {
name <- names(gene_lists)[i]
html_content <- paste0(
html_content,
"<li>", name, ": ", length(gene_lists[[i]]), " genes</li>"
)
}
html_content <- paste0(html_content, "</ul>")
# Ajouter les 10 premiers gènes communs s'il y en a
if (length(common_all) > 0) {
show_genes <- common_all[1:min(10, length(common_all))]
html_content <- paste0(
html_content,
"<p><strong>Top genes common to all sets:</strong> ",
paste(show_genes, collapse = ", "),
if(length(common_all) > 10) "..." else "",
"</p>"
)
}
return(HTML(html_content))
})
showNotification("Venn diagram generated successfully!", type = "message")
}, error = function(e) {
showNotification(paste0("Error generating Venn diagram: ", e$message), type = "error")
# Afficher un message d'erreur dans le plot
output$venn_plot <- renderPlot({
plot.new()
title(main = "Error generating Venn diagram", sub = e$message, col.main = "red")
text(0.5, 0.5, "Please try with fewer gene lists or contact support", cex = 1.2)
})
})
})
# Télécharger les listes de gènes
output$download_venn_gene_lists <- downloadHandler(
filename = function() {
paste0("venn_gene_lists_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv")
},
content = function(file) {
tryCatch({
req(current_gene_lists())
gene_lists <- current_gene_lists()
# Fonction sécurisée pour l'intersection
safe_intersect_multiple <- function(set_list) {
if (length(set_list) == 0 || any(sapply(set_list, length) == 0)) {
return(character(0))
}
result <- set_list[[1]]
if (length(set_list) == 1) {
return(result)
}
for (i in 2:length(set_list)) {
result <- intersect(result, set_list[[i]])
}
return(result)
}
# Générer un dataframe avec toutes les combinaisons d'ensembles
result_df <- data.frame(
Category = character(),
Count = integer(),
Genes = character(),
stringsAsFactors = FALSE
)
# Ajouter chaque ensemble individuel
for (name in names(gene_lists)) {
result_df <- rbind(result_df, data.frame(
Category = name,
Count = length(gene_lists[[name]]),
Genes = paste(gene_lists[[name]], collapse = ", "),
stringsAsFactors = FALSE
))
}
# Calculer toutes les intersections de 2 ou plus
if (length(gene_lists) >= 2) {
# Générer toutes les combinaisons possibles de 2 à n ensembles
for (k in 2:length(gene_lists)) {
combos <- combn(names(gene_lists), k, simplify = FALSE)
for (combo in combos) {
# Calculer l'intersection de façon sécurisée
intersection <- safe_intersect_multiple(gene_lists[combo])
if (length(intersection) > 0) {
# Nommer l'intersection
combo_name <- paste(combo, collapse = " & ")
# Ajouter au résultat
result_df <- rbind(result_df, data.frame(
Category = combo_name,
Count = length(intersection),
Genes = paste(intersection, collapse = ", "),
stringsAsFactors = FALSE
))
}
}
}
}
# Trier par nombre de gènes (décroissant)
if (nrow(result_df) > 0) {
result_df <- result_df[order(-result_df$Count), ]
# Sauvegarder en CSV
write.csv(result_df, file, row.names = FALSE)
showNotification("Gene lists saved successfully!", type = "message")
} else {
# Cas où aucun résultat n'est généré
write.csv(data.frame(Category = "No results", Count = 0, Genes = ""), file, row.names = FALSE)
showNotification("No intersection results to save!", type = "warning")
}
}, error = function(e) {
# En cas d'erreur, créer un fichier minimal
write.csv(data.frame(
Category = "Error occurred",
Count = 0,
Genes = paste("Error:", e$message),
stringsAsFactors = FALSE
), file, row.names = FALSE)
showNotification(paste0("Error saving gene lists: ", e$message), type = "error")
})
}
)
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
# Generate spatial dot plot by clusters
observeEvent(input$show_spatial_dotplot, {
genes_from_text <- character(0)
if (!is.null(input$spatial_dotplot_genes_text) && nchar(trimws(input$spatial_dotplot_genes_text)) > 0) {
genes_from_text <- trimws(strsplit(input$spatial_dotplot_genes_text, ",")[[1]])
genes_from_text <- genes_from_text[genes_from_text != ""]
}
if (length(genes_from_text) == 0) {
showNotification("Please enter at least one gene for dot plot", type = "warning")
return()
}
req(spatial_obj())
tryCatch({
obj <- spatial_obj()
if (!"seurat_clusters" %in% colnames(obj@meta.data)) {
showNotification("Please run clustering first", type = "warning")
return()
}
selected_genes <- genes_from_text
selected_assay <- input$spatial_viz_assay %||% "Spatial"
# Validate genes exist in assay
available_genes <- rownames(obj[[selected_assay]])
valid_genes <- selected_genes[selected_genes %in% available_genes]
if (length(valid_genes) == 0) {
showNotification("Selected genes not found in current assay", type = "error")
return()
}
# Set assay temporarily
original_assay <- DefaultAssay(obj)
DefaultAssay(obj) <- selected_assay
output$spatial_dotplot <- renderPlot({
p <- DotPlot(obj,
features = valid_genes,
group.by = "seurat_clusters",
scale = input$spatial_dot_scale %||% TRUE,
scale.by = input$spatial_dot_scale_by %||% "radius",
dot.min = (input$spatial_dot_min %||% 0)/100,
dot.scale = input$spatial_dot_max %||% 6,
cluster.idents = input$spatial_dot_cluster_idents %||% FALSE,
cols = input$spatial_dot_colors %||% "RdYlBu")
p + theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5)) +
labs(x = "Genes", y = "Clusters",
subtitle = paste("Assay:", selected_assay)) +
coord_flip()
})
# Restore original assay
DefaultAssay(obj) <- original_assay
showNotification(paste("Dot plot generated using", selected_assay, "assay"), type = "message")
}, error = function(e) {
showNotification(paste("Error generating dot plot:", e$message), type = "error")
})
})
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
library(shiny); runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
# Restore original assay
DefaultAssay(obj) <- original_assay
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
runApp('Desktop/App_split/App_split_prod/Code/main_server.R')
